{"version":3,"sources":["../../../../src/modules/cache/methods/get.js"],"names":["ERROR_INFO","module","action","app","plugin","key","setCb","tags","Promise","reject","property","undefined","Array","isArray","resolve","client","hgetall","__get","err","res","callSetIfCallbackExists","then","act","JSON","parse","value","parseReviver","promise","search","Date"],"mappings":"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","file":"get.js","sourcesContent":["import isString from 'lodash.isstring';\nimport isFunction from 'lodash.isfunction';\nimport { MODULE_NAME, ACTION_NAME_GET } from '../constants';\nimport { PIN_CACHE_SET } from '../pins';\nimport { PIN_TAGS_HAS } from '../../pins';\nimport internalError from '../../../errors/internal-error';\nimport propertyIsRequiredError from '../../../errors/property-is-required-error';\nimport tagsMustBeFunctionOrUndefinedError from './../errors/setCb-must-be-function-or-undefined';\nimport tagsMustBeArrayOrUndefinedError from './../errors/tags-must-be-array-or-undefined';\n\nconst ERROR_INFO = { module: MODULE_NAME, action: ACTION_NAME_GET };\n\n/**\n * Получает значение ключа из кеша\n * - если передан метод setCb вызовет получение нового значения ключа если такового нет\n *\n * @param {app} app               Экземпляр библиотеки MicroJS\n * @param {object} plugin         Экземпляр плагина\n * @returns {function({key?: *, setCb?: *, tags?: *}): Promise}\n */\nexport default (app, plugin) => {\n  /**\n   * @param {string} key            Ключ кеша\n   * @param {function} [setCb]      Функция получения нового значения\n   * @param {Array<string>} [tags]  Список тегов для установки нового значения\n   *\n   * @returns {Promise<null|*|error>}\n   */\n  return ({ key, setCb, tags }) => {\n    if (!isString(key) || key === '') {\n      return Promise.reject(propertyIsRequiredError({ ...ERROR_INFO, property: 'key' }));\n    }\n  \n    if (!isFunction(setCb) || setCb !== undefined) {\n      return Promise.reject(tagsMustBeFunctionOrUndefinedError(ERROR_INFO));\n    }\n  \n    if (!Array.isArray(tags) || tags !== undefined) {\n      return Promise.reject(tagsMustBeArrayOrUndefinedError(ERROR_INFO));\n    }\n    \n    return new Promise((resolve, reject) => {\n      plugin.client.hgetall(key, __get);\n  \n      function __get(err, res) {\n        if (err) {\n          return reject(internalError(app, err, ERROR_INFO));\n        }\n    \n        // Запрашиваемый ключ отсутвует\n        if (res === null) {\n          // запустим проверку на обновление по setCb\n          return callSetIfCallbackExists(app, { key, setCb, tags })\n            .then(resolve, reject);\n        }\n    \n        // Проверим актуальность тегов\n        app.act({ ...PIN_TAGS_HAS, tags: res.tags })\n          .then(\n            // Если теги актуальны - вернем результат\n            () => resolve(JSON.parse(res.value, parseReviver)),\n            // Иначе запустим проверку на обновление\n            () => callSetIfCallbackExists(app, { key, setCb, tags })\n          );\n      }\n    });\n  };\n};\n\n/**\n * Вызывает функцию setCb если он был передан для установки нового значения ключа в кеше\n *\n * @param {app} app               Экземпляр библиотеки MicroJS\n * @param {string} key            Ключ кеша\n * @param {function} [setCb]      Функция получения нового значения\n * @param {Array<string>} [tags]  Список тегов для установки нового значения\n *\n * @returns {Promise<null|*>}     Вернет новое значение для ключа\n */\nfunction callSetIfCallbackExists(app, { key, setCb, tags }) {\n  return new Promise((resolve, reject) => {\n    if (isFunction(setCb)) {\n      let promise = setCb(key);\n    \n      if (!promise || !('then' in promise && isFunction(promise.then))) {\n        promise = Promise.resolve(promise);\n      }\n    \n      return promise\n        .then(value => app.act({ ...PIN_CACHE_SET, key, value, tags }))\n        .then(resolve, reject);\n    }\n  \n    return resolve(null);\n  });\n}\n\n/**\n * Функция вызывается для каждой пары ключ / значение при JSON.parse\n * - нужны чтобы корректно распарсить и восстановить дату в виде объекта Date\n *\n * @param {string} key\n * @param {*} value\n * @returns {*}\n */\nfunction parseReviver(key, value) {\n  if (!!value && !!value.search && !!~value.search(/^[0-9]{4}[-]{1}[0-9]{2}[-]{1}[0-9]{2}[A-Z]{1}[0-9]{2}[:]{1}[0-9]{2}[:]{1}[0-9]{2}[\\.]{1}[0-9]{3}[A-Z]{1}$/)) {\n    return new Date(value);\n  }\n  return value;\n}"]}